{
  "posts": [
    {
      "title":"Day 5",
      "summary": "Today I learned about Reagent and reframe, two libraries that act as React wrappers for ClojureScript. Continuing from my previous Clojure experience, I was about to make a standard static website using React/Webpack etc but decided to try a ClojureScript implementation.",
    "data": [
      {
        "type": "text",
        "text": "Today I learned about Reagent and reframe, two libraries that act as React wrappers for ClojureScript. Continuing from my previous Clojure experience, I was about to make a standard static website using React/Webpack etc but decided to try a ClojureScript implementation."
      },
      {
        "type": "text",
        "text": "I started my new website by using a tool called leiningen, which is a project configurator that can be used for a variety of project types. I chose to create a re-frame project which is like a React project (it uses another ClojureScript library called Reagent) with Redux baked in."
      },
      {
        "type": "text",
        "text": "Writing the React components themselves was really easy, even easier than writing the JavaScript equivalent. A simple stateless react component can be composed as follows:"
      },
      {
        "type": "code",
        "code": "(defn work-panel []\n    [:div\n     [:div {:style {:display \"flex\" :flex-direction \"column\" :align-items \"center\"}}\n      [navbar]\n     ]]))"
      },
      {
        "type": "text",
        "text": "Inline styles can be applied easily with a style key and other react components can be easily added to existing components by surrounding the component name with square brackets like above with the 'navbar' component."
      },
      {
        "type": "text",
        "text": "I also wanted something like CSS-modules or a way of writing my styles in an organized fashion within ClojureScript. Luckily, there is an existing library that does just that called cljss or clojure style sheets."
      },
      {
        "type": "text",
        "text": "Shown in the code snippet below, using cljss, you can easily define css classes using the defstyles function and then evaluate them as the value of a class key inside a reagent DOM element (the example below is styling an input submit button)."
      },
      {
        "type": "code",
        "code": "(defstyles submitButton []\n           { :background-color \"#D8D8D8\"\n            :width \"355px\"\n            :height \"35px\"\n            :color \"white\"\n            :border \"none\"\n            })\n            \n[:input {:type \"submit\" :value \"Contact Me\" :class (submitButton)}]"
      },
      {
        "type": "text",
        "text": "Since everything in ClojureScript is function, far more advanced classes can be created to determine the styles parameters based off of parameters given to the style function (see example below)."
      },
      {
        "type": "code",
        "code": "(defstyles lastName [fontSize]\n  { :position \"absolute\"\n    :transform \"rotate(90deg)\"\n    :right \"0px\"\n    :bottom (str fontSize \"px\")\n    :width \"0px\"\n    :height (str(+ fontSize 60) \"px\")\n    :font-size (str fontSize \"px\")\n   })"
      }
      ]
    },
    {
      "title":"Day 4",
      "summary": "Today I learned the basics of a LISP like language called Clojure. I was looking into RxJS, which is a library that uses a type of programming called 'Reactive Programming' (I will save that for another day), and I came across an article that talked about a language called clojure. ",
      "data": [
        {
          "type": "text",
          "text": "Today I learned the basics of a LISP like language called Clojure. I was looking into RxJS, which is a library that uses a type of programming called 'Reactive Programming' (I will save that for another day), and I came across an article that talked about a language called clojure. "
        },
        {
          "type": "text",
          "text": "LISP, short for LISt Processor, are a group of languages that seemingly do not have a clear definition. From my very brief experience, writing Clojure is like a mix of writing bash and JavaScript. The syntax is really easy and you can be productive almost from the get-go but the programming style is completely different from other OO languages such as Java/C++."
        },
        {
          "type": "text",
          "text": "A very straightforward example of the \"Hello World\" equivalent in lisp is:"
        },
        {
          "type": "code",
          "code": "(println Hello World)"
        },
        {
          "type": "text",
          "text": "All the magic in the line happens within parenthesizes: they are pivotal to Clojure. In clojure all programs can be written as (function argument). "
        },
        {
          "type": "text",
          "text": "Everything is evaluated instantly and the language emphasizes the use its RePL (read evaluate print loop: think developer tools console for JavaScript)."
        },
        {
          "type": "text",
          "text": "Clojure supports a variety of primitives like integers/floats, characters/strings, booleans, nils and it supports the collectives list, vector, set and map which all come with specific operations unique to them."
        },
        {
          "type": "text",
          "text": "I think the most interesting part of Clojure is that everything can be built via a series of (function argument) lines. There is something beautiful with the recursive like syntax that makes it feel like you're programming for the first time again."
        },
        {
          "type": "text",
          "text": "A more expressive example is shown below:"
        },
        {
          "type": "code",
          "code": "(defn make-thingy ([x] (fn [& args] x)))"
        },
        {
          "type": "code",
          "code": "((make-thingy 5) 8)"
        },
        {
          "type": "text",
          "text": "In this example, the defn keyword allows us to [def]ine a [f]u[n]ction called make-thingy which takes one parameter 'x' which returns another function in which we can do whatever we want and it returns the original argument. In order to call it we write the call syntax and supply it with an argument (make-thingy 5) and since it returns a function we need to supply that with another argument (which, in this case, is not used)."
        },
        {
          "type": "text",
          "text": "A great thing about Clojure is that there is also 'ClojureScript' which is basically Clojure that can be compiled to JavaScript. Moreover, you can easily use the React framework with ClojureScript making it an excellent front-end tool to make fault tolorant components. I plan on developing the rest of my blog using ClojureScript in order to further farmiliarize myself with the language."
        }
      ]
    },
    {
      "title":"Day 3",
      "summary": "Today I learned about a new JavaScript design pattern called the Observer. The observer pattern is kind of like DOM event listeners in the sense that it is used to inform a set of listeners when a specific event happens. That being said, it differs in that any number of objects can subscribe to an ‘event’ and you can specify when the objects are informed that there has been an update.",
      "data": [
        {
          "type": "text",
          "text": "Today I learned about a new JavaScript design pattern called the Observer. The observer pattern is kind of like DOM event listeners in the sense that it is used to inform a set of listeners when a specific event happens. That being said, it differs in that any number of objects can subscribe to an ‘event’ and you can specify when the objects are informed that there has been an update."
        },
        {
          "type": "text",
          "text": "The observer design pattern consists of two components: the subject and the observers. An observer is an object that can subscribe to a subject, whos job is to maintain of list of observers and can notify them when nessessary."
        },
        {
          "type": "text",
          "text": "The implementation of the pattern is pretty easy. Observers are just objects that have a common ‘update’ function but the ‘update’ function is arbitrary and can be called whatever you like:"
        },
        {
          "type": "code",
          "code": "function Observer() {\nthis.update = function(upd) {\n…\n}\n}"
        },
        {
          "type": "text",
          "text": "The subject can be implemented as a list of observers with a function used to update all subscribed observers:"
        },
        {
          "type": "code",
          "code": "function Subject() {\nthis.observers = []\n\nthis.notify = function(upd) {\nfor (let obs of observers)\nobs.update(upd)\n}\n}"
        },
        {
          "type": "text",
          "text": "This is a bare minimum example but it wouldn't be hard to extend it to include more advanced functionality."
        }
      ]
    },
    {
      "title":"Day 2",
      "summary": "Today I learned about UPC++, a distributed computing library for C++ made by Berkley University. The idea of UPC++ is based on partitioned global address spaces. In these spaces computer processors can directly name (by address) memory, and write to, memory inside another processors memory",
      "data": [
        {
          "type": "text",
          "text": "Today I learned about UPC++, a distributed computing library for C++ made by Berkley University. The idea of UPC++ is based on partitioned global address spaces. In these spaces computer processors can directly name (by address) memory, and write to, memory inside another processors memory. "
        },
        {
          "type": "text",
          "text": "In a typical system, two processors would communicate by sending messages where one process would send and another recieves. Using UPC++, a process can write directly to another processes memory using a remote data memory access operation (RDMA) (I think this is similar to direct memory access). A major advantage gained with this system is a reduction in overhead due to lack of a typical send/recieve pattern."
        },
        {
          "type": "text",
          "text": "To show an example, in UPC++, shared memory is allocated explicitly:"
        },
        {
          "type": "code",
          "code": "Global_ptr<int> gptr = upcxx::new_<int>(rank_me());"
        },
        {
          "type": "text",
          "text": "This line allocates a new global integer inside its processors memory which now can be accessed via other processors."
        },
        {
          "type": "text",
          "text": "Very similar to JavaScript, there is no implicit blocking in UPC++ allowing powerful asynchronous calls to global memory. As a result, you can pipeline computations with data accesses with the added benifit of RDMA."
        },
        {
          "type": "text",
          "text": "Asynchronous calls can be made as simple as using:"
        },
        {
          "type": "code",
          "code": "upcxx::future<T> f1 = upcxx::rget(gptr1);"
        },
        {
          "type": "text",
          "text": "To block until the data is available one only needs to call:"
        },
        {
          "type": "code",
          "code": "upcxx:wait(f1)"
        },
        {
          "type": "text",
          "text": "making the syntax easy and accessible."
        }
      ]
    },
    {
      "title":"Day 1",
      "summary": "Today I learned about GitHub pages. Github pages, (what is currently powering this blog) is a service used to serve static content residing on a github repository. I was looking for an easy way of serving a static blog for this learning journal and stumbled across pages.",
      "data": [
        {
          "type": "text",
          "text": "Today I learned about GitHub pages. Github pages, (what is currently powering this blog) is a service used to serve static content residing on a github repository. I was looking for an easy way of serving a static blog for this learning journal and stumbled across pages."
        },
        {
          "type": "text",
          "text": "It was straightforward to setup: all you need to do is create a repository using yourusername.github.io and then create an index.html page in the root directory of the repository. However, I wanted to whip something up using react however so I bootstrapped a small React project using webpack+babel."
        },
        {
          "type": "text",
          "text": "The web content is served by default from your master branch. In order to keep things clean, I created another branch called development to house the react files. I built my bundle.js/index.html files to a dist directory. In order to deploy the site I used `git subtree` to build a sub-branch, (called _website_ ) inside of the dist folder and then I created a deploy script to push the website branch to master."
        },
        {
          "type": "image",
          "url": "./ghpages.png"
        }
      ]
    }
  ]
}
